# task_tree

⮬ Название проекта.

# Постановка задачи

Многие люди нуждаются в каком-то структурированном способе фиксировать свои задачи.
Некоторые пользуются ручными дневниками, кто-то - календарем, а кто-то предпочитает хранить свои задачи в текстовом файле в папке с документами или на рабочем столе.
Во всех этих подходах есть свои плюсы и минусы. Существует не бесконечное, но достаточно большое кол-во утилит, которые позволяют организовывать свои задачи,
устанавливать дедлайны, прикреплять файлы, делиться списком задач и т.д. Большинство из них, так или иначе, будут платными.

Мы предлагаем новый продукт - task_tree, который, по сути, работает как простенькая иерархическая база данных. От корня дерева идут ветви к другим поддеревьям, 
что позволяет наглядно представлять себе задачу и ее внутреннюю структуру. Это может быть полезно любым людям, которые нуждаются в способе фиксировать свои планы.

Чтобы не быть голословным, рекомендуем обратиться к этому источнику, где вы на практике можете ощутить все положительные стороны такого подхода:

https://www.mindmeister.com/

# Базовая функциональность

Наш продукт будет в первую очередь рассчитан на локальное использование. 

Реализовав основной функционал, мы можем сосредоточиться на добавлении дополнительных возможностей, реализации собственного веб-сервиса, подобного `mindmeister` и др.

Возможно, приложение будет разбито на несколько модулей, но целевой функционал должен быть следующим:

- Возможность создать, модифицировать, редактировать и удалять поддеревья на локальной машине. 
	- Сохранение и удаление файлов с поддеревьями (а это означает необходимость проработать способ их хранения и структуру файла).
	- Реализация простого command-line интерфейса, в котором целевой пользователь может:
		* Просматривать сохраненные поддеревья.
		* Добавлять к поддеревьям новые ветви или вершины.
		* Отмечать определенные задачи как выполненные или не выполненные.
		* Сохранять дерево в текстовый файл, который будет удобно читаемым и легко изменяемым.

# Вокрфлоу юзера

* Когда пользователь садится за свой ноутбук, он загружает ОС. 
* Пока ОС загружается, пользователь продумывает задачи, которые он должен сделать за данный сеанс работы с компьютером.
* Пользователь открывает наш продукт - запускает нужный модуль через терминал. 
* Последовательностью команд пользователь создает дерево задач.
* Далее пользователь начинает выполнять задачи, по мере их решения он возвращается к нашему модулю, чтобы пометить нужную задачу завершенной.
* В конце сеанса работы пользователь проверяет дерево задач на тот факт, что оно полностью выполнено.
* Если не все задачи выполнены, пользователь сохраняет дерево для следующего сеанса работы.
	* В отличие от блокнота, в котором пользователю может быть и будет удобней работать, наш продукт сохраняет файл в каталог по умолчанию.
	* Таким образом пользователю не надо задумываться о том, где хранятся деревья.
* Завершение работы.

# Особенности реализации или *на какие задачи можно разбить проект*

Мы заботимся о архитектуре заранее, чтобы в будущем добавлять новые фичи было удобно. 

В первоначальном виде структура проекта примерно такая:

1. Модуль core. Отвечает за непосредственное редактирование дерева.
	* Необходимо предусмотреть следующий функционал:
	* Вершины дерева - они же задачи, могут иметь статус `SOLVED`, `FAILED`, или `PENDING`. Состояние по умолчанию - `PENDING`. 
	* К вершинам дерева можно добавлять другие вершины, следует предусмотреть различные связи между вершинами, среди которых обязательно должны быть следующие:
		* Если все поддеревья решены с успехом, но корень-вершина автоматически помечается как завершенная с успехом.
		* Если корень отмечен завершенным с успехом, то все вершины автоматически помечаются завершенными с успехом.
	* (*детали реализации*) Возможно, стоит реализовать события выше именно как события. 
		* То есть, у нас имеется сущность - вершина, которая подписывается на события дочерних вершин.
		* Первоначальными событиями являются проставление `SOLVED`, `FAILED` флагов.
		* Родительская вершина обрабатывает события дочерних вершин и автоматически выполняет какие-то действия.
		* (*почему это может быть полезно*) Представим ситуацию, когда вы создали задачу и по ее успешном завершении вам надо принять какие-то действия, например, после редактирования каталога надо сделать `commit`. Вы можете воспользоваться нашим продуктом для автоматизации этой задачи. Для этого в вершину добавляется `listener` на указанное событие, который срабатывает тогда, когда вы установили вершину в `SOLVED`. Чтобы указать системе, что конкретно надо сделать, можно использовать bash-скрипт или питон. Да, этот аспект нашего продукта может быть не реализован в рамках семестрового проекта, однако учитывая все факты, стоит уже на этом этапе задуматься о том, какой функционал может иметь в себе наш продукт, иными словами, мы заботимся о деталях реализации заранее, чтобы добавления новых фичей или возможностей было максимально просто и удобно в будущем.
2. Модуль save/load. Отвечает за сохранения дерева внутри системы.
	* Это может быть БД, это может быть просто текстовый или бинарный файл.
	* Однако, если вынести этот функционал в отдельный модуль, в будущем можно добавить другую реализацию этого же API: например, обращение к серверу и сохранение деревьев на удаленной машине.
3. Модуль cli. Он же command line interface.
	* Обязательная часть нашего продукта, потому что именно она является посредником между конечным пользователем и core модулем.
	* Здесь пользователю надо отобразить список сохраненных поддеревьев, отобразить сами деревья, в удобном виде предоставить способы взаимодействия с модулем core.
	* опять же, вынося это в отдельный модуль, мы делаем возможным использование вместо cli какого-нибудь GUI или фронтенда. 
4. Модуль экспорта/импорта дерева в файл. 
	* Если пункт 2 относился к непосредственному сохранению, то эту функциональность мы выносим в отдельный модуль просто потому, что она не принадлежит никаким другим.
	* В пункте 2 речь шла о сохранении, здесь речь идет о удобном представлении дерева в текстовом виде. 
	* Зачем это надо? Чтобы пользователь мог вместо cli выполнить экспорт в файл, затем выполнить редактирование этого файла в удобном ему редакторе, затем выполнить импорт файла.
	* Теперь редактирование возможно не только при помощи cli, но и при помощи собственного текстового редактора.

# Мотивация и заключение

Это семестровый проект, нас - разработчиков - 3 человека и для нас реализация этого ТЗ не займет больше полутора недель.
Кроме того, данное направление перспективное :
* От фронтенда сервера до REST API.
* От телеграммного бота до приложений на android.
* От прикрепления фотографий до share-деревьев и прикрепления любых файлов или заметок. Комментирование.
* От автоматических событий до собственного языка программирования.
* От импорта github issue до экспорта в google calendar.
* Обратите внимание, что core модуль может стать полноценным питоньим модулем и залететь на `pypi`!
* Сериализация и десериализация. Экспорт дерева в картинку. GUI.
* В случае сервера можно выполнять выборочный share: делиться не деревом, а конкретными вершинами.
* (*детали реализации*) Классификация связей, когда дерево уже больше похоже на ориентированный граф.
* Добавление делайнов к вершинам. Вывод не в виде дерева, а в виде расписания. Напоминания и уведомления.
* Статистика (отображение состояния выполненной задачи в процентах).
* Метки или тэги, по которым удобно было бы быстро перемещаться по дереву.
* Можно указывать стоимость каждой вершины и автоматически считать стоимость всех запланированных дел.
* и тд.

Это список возможных направлений разработки. Очевидно, что это не уместится в семестровый проект, однако само наличие такого спектра возможностей и направлений развития лишь подтверждает наш выбор в сторону именно `task_tree`. Более того, `КН9IZ` готов предоставить свой код как готовую часть реализации (ближайшая задача нашей команды - оценить, насколько имеющаяся у нас кодовая база соответствует поставленной задаче).

На этом описание нашего семестрового проекта с лаконичным названием `task_tree` является завершенным. Спасибо, что уделили время на прочтение.